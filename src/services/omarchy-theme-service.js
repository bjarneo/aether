/**
 * OmarchyThemeService - Discovery and management of installed Omarchy themes
 *
 * Discovers themes in ~/.config/omarchy/themes/, parses colors from either
 * colors.toml (Aether-generated) or kitty.conf (default Omarchy themes),
 * and provides theme metadata and actions.
 *
 * @module omarchy-theme-service
 */

import GLib from 'gi://GLib';
import Gio from 'gi://Gio';

import {readFileAsText, enumerateDirectory, fileExists} from '../utils/file-utils.js';
import {parseColorsToml, isColorsTomlFormat} from '../utils/toml-utils.js';

/**
 * @typedef {Object} OmarchyTheme
 * @property {string} name - Directory name
 * @property {string} path - Full path to theme directory
 * @property {string[]} colors - 16 ANSI colors (hex)
 * @property {string} background - Background color (hex)
 * @property {string} foreground - Foreground color (hex)
 * @property {Object} extendedColors - Extended colors (accent, cursor, etc.)
 * @property {string|null} description - First line from README.md
 * @property {string|null} previewImage - Path to preview image
 * @property {string[]} wallpapers - Paths to wallpapers in backgrounds/
 * @property {boolean} isSymlink - Whether theme is a symlink
 * @property {string|null} symlinkTarget - Target path if symlink
 * @property {boolean} isCurrentTheme - Whether this is the active theme
 * @property {boolean} isAetherGenerated - Whether generated by Aether
 */

/**
 * User themes directory path (~/.config/omarchy/themes)
 * @constant {string}
 */
const USER_THEMES_DIR = GLib.build_filenamev([
    GLib.get_home_dir(),
    '.config',
    'omarchy',
    'themes',
]);

/**
 * System themes directory path (~/.local/share/omarchy/themes)
 * @constant {string}
 */
const SYSTEM_THEMES_DIR = GLib.build_filenamev([
    GLib.get_home_dir(),
    '.local',
    'share',
    'omarchy',
    'themes',
]);

/**
 * Current theme file path
 * @constant {string}
 */
const CURRENT_THEME_FILE = GLib.build_filenamev([
    GLib.get_home_dir(),
    '.config',
    'omarchy',
    'current',
    'theme.name',
]);

/**
 * Aether theme output directory
 * @constant {string}
 */
const AETHER_THEME_DIR = GLib.build_filenamev([
    GLib.get_home_dir(),
    '.config',
    'aether',
    'theme',
]);

/**
 * OmarchyThemeService class
 */
export class OmarchyThemeService {
    constructor() {
        /** @private @type {OmarchyTheme[]} */
        this._themes = [];

        /** @private @type {string|null} */
        this._currentThemeName = null;
    }

    /**
     * Load all installed Omarchy themes from both user and system directories
     * @returns {Promise<OmarchyTheme[]>} Array of theme objects
     */
    async loadAllThemes() {
        this._themes = [];
        this._currentThemeName = this.getCurrentThemeName();

        // Track theme names to avoid duplicates (user themes take priority)
        const loadedThemeNames = new Set();

        // Load themes from a directory
        const loadFromDirectory = (themesDir, isSystemTheme = false) => {
            const dir = Gio.File.new_for_path(themesDir);
            if (!dir.query_exists(null)) {
                return;
            }

            try {
                enumerateDirectory(themesDir, (fileInfo, filePath, fileName) => {
                    const fileType = fileInfo.get_file_type();
                    if (fileType !== Gio.FileType.DIRECTORY && fileType !== Gio.FileType.SYMBOLIC_LINK) {
                        return;
                    }

                    // Skip hidden directories
                    if (fileName.startsWith('.')) {
                        return;
                    }

                    // Skip if already loaded from user directory
                    if (loadedThemeNames.has(fileName)) {
                        return;
                    }

                    const theme = this._loadTheme(filePath, fileName, fileInfo, isSystemTheme);
                    if (theme) {
                        this._themes.push(theme);
                        loadedThemeNames.add(fileName);
                    }
                }, 'standard::name,standard::type,standard::is-symlink,standard::symlink-target');
            } catch (e) {
                console.error(`Error loading themes from ${themesDir}:`, e.message);
            }
        };

        // Load user themes first (they take priority)
        loadFromDirectory(USER_THEMES_DIR, false);

        // Load system themes
        loadFromDirectory(SYSTEM_THEMES_DIR, true);

        // Sort themes alphabetically, with current theme first
        this._themes.sort((a, b) => {
            if (a.isCurrentTheme) return -1;
            if (b.isCurrentTheme) return 1;
            return a.name.localeCompare(b.name);
        });

        return this._themes;
    }

    /**
     * Get the current active theme name
     * @returns {string|null} Current theme name or null
     */
    getCurrentThemeName() {
        try {
            if (!fileExists(CURRENT_THEME_FILE)) {
                return null;
            }
            const content = readFileAsText(CURRENT_THEME_FILE);
            return content.trim();
        } catch (e) {
            console.error('Error reading current theme:', e.message);
            return null;
        }
    }

    /**
     * Apply a theme by name
     * @param {string} themeName - Theme name to apply
     * @returns {Promise<boolean>} Success status
     */
    async applyTheme(themeName) {
        try {
            const subprocess = Gio.Subprocess.new(
                ['omarchy-theme-set', themeName],
                Gio.SubprocessFlags.NONE
            );
            const success = await new Promise((resolve) => {
                subprocess.wait_async(null, (proc, result) => {
                    try {
                        proc.wait_finish(result);
                        resolve(proc.get_successful());
                    } catch (e) {
                        console.error('Error running omarchy-theme-set:', e.message);
                        resolve(false);
                    }
                });
            });
            return success;
        } catch (e) {
            console.error('Error applying theme:', e.message);
            return false;
        }
    }

    /**
     * Get cached themes (without reloading)
     * @returns {OmarchyTheme[]} Cached themes
     */
    getThemes() {
        return [...this._themes];
    }

    /**
     * Load a single theme from its directory
     * @private
     * @param {string} themePath - Full path to theme directory
     * @param {string} themeName - Theme directory name
     * @param {Gio.FileInfo} fileInfo - File info object
     * @param {boolean} isSystemTheme - Whether this is a system theme
     * @returns {OmarchyTheme|null} Theme object or null
     */
    _loadTheme(themePath, themeName, fileInfo, isSystemTheme = false) {
        try {
            // Check for symlink
            const isSymlink = fileInfo.get_is_symlink();
            let symlinkTarget = null;
            let resolvedPath = themePath;

            if (isSymlink) {
                symlinkTarget = fileInfo.get_symlink_target();
                // Resolve relative symlinks
                if (symlinkTarget && !symlinkTarget.startsWith('/')) {
                    resolvedPath = GLib.build_filenamev([USER_THEMES_DIR, symlinkTarget]);
                } else {
                    resolvedPath = symlinkTarget;
                }
            }

            // Check if resolved path exists
            if (!fileExists(resolvedPath)) {
                console.warn(`Theme ${themeName} points to non-existent path: ${resolvedPath}`);
                return null;
            }

            // Determine if this is an Aether-generated theme
            const isAetherGenerated = isSymlink && symlinkTarget === AETHER_THEME_DIR;

            // Extract colors
            const colorResult = this._extractColors(resolvedPath);
            if (!colorResult) {
                // Skip themes without colors.toml
                return null;
            }

            // Get metadata
            const metadata = this._getThemeMetadata(resolvedPath, themeName);

            return {
                name: themeName,
                path: themePath,
                colors: colorResult.colors,
                background: colorResult.background,
                foreground: colorResult.foreground,
                extendedColors: colorResult.extendedColors || {},
                description: metadata.description,
                previewImage: metadata.previewImage,
                wallpapers: metadata.wallpapers,
                isSymlink,
                symlinkTarget,
                isCurrentTheme: themeName === this._currentThemeName,
                isAetherGenerated,
                isSystemTheme,
            };
        } catch (e) {
            console.error(`Error loading theme ${themeName}:`, e.message);
            return null;
        }
    }

    /**
     * Extract colors from a theme directory
     * Only uses colors.toml format (Aether/ethereal/Omarchy standard)
     * @private
     * @param {string} themePath - Theme directory path
     * @returns {{colors: string[], background: string, foreground: string, extendedColors: Object}|null}
     */
    _extractColors(themePath) {
        // Only use colors.toml (standard Omarchy format)
        const colorsTomlPath = GLib.build_filenamev([themePath, 'colors.toml']);
        if (fileExists(colorsTomlPath)) {
            try {
                const content = readFileAsText(colorsTomlPath);
                if (isColorsTomlFormat(content)) {
                    return parseColorsToml(content);
                }
            } catch (e) {
                console.warn(`Failed to parse colors.toml in ${themePath}:`, e.message);
            }
        }

        return null;
    }

    /**
     * Get theme metadata (description, preview image, wallpapers)
     * @private
     * @param {string} themePath - Theme directory path
     * @param {string} themeName - Theme name
     * @returns {{description: string|null, previewImage: string|null, wallpapers: string[]}}
     */
    _getThemeMetadata(themePath, themeName) {
        let description = null;
        let previewImage = null;
        const wallpapers = [];

        // Try to get description from README.md
        const readmePath = GLib.build_filenamev([themePath, 'README.md']);
        if (fileExists(readmePath)) {
            try {
                const content = readFileAsText(readmePath);
                const lines = content.split('\n').filter(l => l.trim());
                // Get first non-empty line, skip markdown headers
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed.startsWith('#')) {
                        // Extract title from header
                        description = trimmed.replace(/^#+\s*/, '');
                        break;
                    } else if (trimmed) {
                        description = trimmed;
                        break;
                    }
                }
            } catch (e) {
                // Ignore
            }
        }

        // Find preview image (in priority order)
        const previewCandidates = ['screenshot.png', 'logo.png', 'theme.png', 'preview.png'];
        for (const candidate of previewCandidates) {
            const imagePath = GLib.build_filenamev([themePath, candidate]);
            if (fileExists(imagePath)) {
                previewImage = imagePath;
                break;
            }
        }

        // Get wallpapers from backgrounds directory
        const backgroundsDir = GLib.build_filenamev([themePath, 'backgrounds']);
        if (fileExists(backgroundsDir)) {
            try {
                enumerateDirectory(backgroundsDir, (fileInfo, filePath, fileName) => {
                    const contentType = fileInfo.get_content_type();
                    if (contentType && contentType.startsWith('image/')) {
                        wallpapers.push(filePath);
                    }
                }, 'standard::name,standard::content-type');
            } catch (e) {
                // Ignore
            }
        }

        // If no preview image, try first wallpaper
        if (!previewImage && wallpapers.length > 0) {
            previewImage = wallpapers[0];
        }

        return {description, previewImage, wallpapers};
    }
}

/**
 * Singleton instance
 * @type {OmarchyThemeService}
 */
export const omarchyThemeService = new OmarchyThemeService();
